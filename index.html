<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TERMINAL-1954 â€” Authentic Computing Interface</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    
    :root{
      --bg: #000000;
      --green: #00ff41;
      --green-dim: #008f11;
      --green-bright: #41ff00;
      --green-faint: #004411;
      --red: #ff4444;
      --scan-opacity: 0.02;
    }

    * { box-sizing: border-box; }
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: var(--bg);
      font-family: 'JetBrains Mono', 'Courier New', monospace;
      color: var(--green);
      cursor: none;
    }

    .terminal {
      width: 100vw;
      height: 100vh;
      background: var(--bg);
      position: relative;
      overflow: hidden;
    }

    /* CRT scanlines and effects */
    .terminal::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 255, 65, var(--scan-opacity)) 2px,
          rgba(0, 255, 65, var(--scan-opacity)) 4px
        );
      pointer-events: none;
      z-index: 1000;
    }

    /* Screen flicker */
    .terminal::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      opacity: 0;
      pointer-events: none;
      z-index: 999;
      animation: flicker 0.15s infinite linear alternate;
    }

    @keyframes flicker {
      0% { opacity: 0; }
      98% { opacity: 0; }
      99% { opacity: 0.02; }
      100% { opacity: 0; }
    }

    .screen {
      padding: 20px;
      height: 100vh;
      overflow-y: auto;
      overflow-x: hidden;
      background: radial-gradient(ellipse at center, rgba(0, 255, 65, 0.02) 0%, transparent 50%);
      position: relative;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .screen::-webkit-scrollbar {
      display: none;
    }

    .line {
      font-size: 14px;
      line-height: 1.4;
      margin: 0;
      padding: 2px 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .system { color: var(--green-bright); }
    .user { color: var(--green-bright); }
    .bot { color: var(--green); }
    .error { color: var(--red); }

    .prompt-line {
      display: flex;
      align-items: center;
      margin-top: 4px;
    }

    .prompt-symbol {
      color: var(--green-bright);
      margin-right: 8px;
      font-weight: 700;
    }

    .input-area {
      background: transparent;
      border: none;
      outline: none;
      color: var(--green);
      font-family: inherit;
      font-size: 14px;
      flex: 1;
      caret-color: var(--green-bright);
    }

    .cursor {
      display: inline-block;
      width: 8px;
      height: 16px;
      background: var(--green-bright);
      margin-left: 2px;
      animation: blink 1s steps(2) infinite;
      vertical-align: text-bottom;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    .typing-cursor {
      background: var(--green);
      width: 2px;
      animation: typing-blink 0.8s steps(2) infinite;
    }

    @keyframes typing-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Boot sequence styles */
    .boot-text {
      color: var(--green-dim);
      font-size: 12px;
    }

    .header {
      color: var(--green-bright);
      font-weight: 700;
      text-align: left;
      margin: 20px 0;
      font-size: 16px;
    }

    /* Glow effect for text */
    .glow {
      text-shadow: 0 0 5px currentColor, 0 0 10px currentColor, 0 0 15px currentColor;
    }

    /* Sound toggle */
    .sound-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 2000;
      color: var(--green-dim);
      font-size: 10px;
      cursor: pointer;
      user-select: none;
    }

    .sound-toggle:hover {
      color: var(--green);
    }

    /* Screen border glow */
    .terminal {
      box-shadow: 
        inset 0 0 50px rgba(0, 255, 65, 0.1),
        0 0 50px rgba(0, 255, 65, 0.05);
    }
  </style>
</head>
<body>
  <div class="terminal" id="terminal">
    <div class="sound-toggle" id="soundToggle">
      ðŸ”Š AUDIO: ON
    </div>
    
    <div class="screen" id="screen">
      <div id="output"></div>
      <div class="prompt-line" id="promptLine" style="display: none;">
        <span class="prompt-symbol">></span>
        <input type="text" class="input-area" id="input" autocomplete="off" spellcheck="false">
        <span class="cursor" id="cursor"></span>
      </div>
    </div>
  </div>

<script>
// Authentic terminal with realistic vintage computer sounds
const output = document.getElementById('output');
const input = document.getElementById('input');
const promptLine = document.getElementById('promptLine');
const cursor = document.getElementById('cursor');
const soundToggle = document.getElementById('soundToggle');
const screen = document.getElementById('screen');

let audioEnabled = true;
let audioCtx = null;
let isBooting = true;
let currentTypingSound = null;

// Initialize audio context
function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

// Realistic vintage computer sounds
function playTone(frequency, duration, type = 'square', volume = 0.1, attack = 0.01, decay = 0.1) {
  if (!audioEnabled) return;
  initAudio();
  
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  const filterNode = audioCtx.createBiquadFilter();
  
  // Add some filtering for more authentic sound
  filterNode.type = 'lowpass';
  filterNode.frequency.setValueAtTime(frequency * 2, audioCtx.currentTime);
  
  oscillator.type = type;
  oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
  
  // ADSR envelope for more realistic sound
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + attack);
  gainNode.gain.linearRampToValueAtTime(volume * 0.7, audioCtx.currentTime + attack + decay);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  
  oscillator.connect(filterNode);
  filterNode.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  
  oscillator.start(audioCtx.currentTime);
  oscillator.stop(audioCtx.currentTime + duration + 0.1);
}

// Specific sound effects
function playKeyClick() {
  playTone(800 + Math.random() * 200, 0.05, 'square', 0.03);
}

function playEnterKey() {
  playTone(400, 0.1, 'square', 0.08);
  setTimeout(() => playTone(600, 0.05, 'square', 0.04), 50);
}

function playStartupBeep() {
  playTone(800, 0.2, 'sine', 0.1);
  setTimeout(() => playTone(1000, 0.15, 'sine', 0.08), 200);
}

function playTypewriterBell() {
  playTone(1200, 0.1, 'sine', 0.06);
}

function playErrorBeep() {
  playTone(200, 0.3, 'sawtooth', 0.08);
}

// Character-based typing sounds (like teletype)
function charToFreq(char) {
  const code = char.charCodeAt(0);
  return 300 + (code % 50) * 8; // Creates musical variation
}

function playCharSound(char) {
  if (!audioEnabled || char === ' ') return;
  const freq = charToFreq(char);
  playTone(freq, 0.03, 'square', 0.015, 0.005, 0.01);
}

// Add line to terminal
function addLine(text, className = '') {
  const line = document.createElement('div');
  line.className = `line ${className}`;
  line.textContent = text;
  output.appendChild(line);
  scrollToBottom();
}

// Type out text with realistic timing
async function typeText(text, className = '', charDelay = 30) {
  const line = document.createElement('div');
  line.className = `line ${className}`;
  output.appendChild(line);
  
  const typingCursor = document.createElement('span');
  typingCursor.className = 'cursor typing-cursor';
  line.appendChild(typingCursor);
  
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    line.insertBefore(document.createTextNode(char), typingCursor);
    playCharSound(char);
    
    // Variable typing speed for realism
    const delay = charDelay + Math.random() * 20;
    await new Promise(resolve => setTimeout(resolve, delay));
    scrollToBottom();
  }
  
  typingCursor.remove();
  return line;
}

function scrollToBottom() {
  screen.scrollTop = screen.scrollHeight;
}

// Boot sequence
async function bootSequence() {
  playStartupBeep();
  
  await typeText('TERMINAL-1954 BOOT SEQUENCE INITIATED...', 'boot-text system', 20);
  await new Promise(r => setTimeout(r, 500));
  
  await typeText('LOADING CORE SYSTEMS..................... [ OK ]', 'boot-text', 25);
  await typeText('INITIALIZING DISPLAY DRIVERS............. [ OK ]', 'boot-text', 25);
  await typeText('CONNECTING TO POLLINATIONS API........... [ OK ]', 'boot-text', 25);
  await typeText('AUDIO SUBSYSTEM ONLINE................... [ OK ]', 'boot-text', 25);
  
  await new Promise(r => setTimeout(r, 800));
  playTypewriterBell();
  
  await typeText('TERMINAL-1954 â€¢ ANALOG COMPUTING INTERFACE v2.1', 'header glow', 40);
  await typeText('POLLINATIONS TEXT ENGINE â€¢ READY FOR INPUT', 'system', 40);
  
  await new Promise(r => setTimeout(r, 500));
  
  await typeText('\nSYSTEM READY. TYPE YOUR QUERY AND PRESS ENTER.', 'bot', 35);
  await typeText('Examples: "write a short story", "explain quantum physics"\n', 'system', 35);
  
  // Show prompt
  promptLine.style.display = 'flex';
  input.focus();
  isBooting = false;
}

// Handle user input
async function handleInput() {
  const query = input.value.trim();
  if (!query) return;
  
  playEnterKey();
  
  // Display user input
  addLine(`> ${query}`, 'user glow');
  
  // Clear input
  input.value = '';
  input.disabled = true;
  cursor.style.display = 'none';
  
  // Show processing
  const processingLine = await typeText('Processing request...', 'system', 50);
  
  try {
    // Call Pollinations API
    const response = await fetch(`https://text.pollinations.ai/hello/${encodeURIComponent(query)}`);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    const result = await response.text();
    
    // Remove processing line
    processingLine.remove();
    
    // Type out response
    await typeText(`\n${result.trim()}\n`, 'bot', 25);
    
  } catch (error) {
    playErrorBeep();
    processingLine.remove();
    await typeText(`\nERROR: ${error.message}\n`, 'error', 30);
  }
  
  // Re-enable input
  input.disabled = false;
  cursor.style.display = 'inline-block';
  input.focus();
}

// Event listeners
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    if (!isBooting && !input.disabled) {
      handleInput();
    }
  } else if (e.key.length === 1) {
    // Play key sound for printable characters
    setTimeout(() => playKeyClick(), 0);
  }
});

// Sound toggle
soundToggle.addEventListener('click', () => {
  audioEnabled = !audioEnabled;
  soundToggle.textContent = audioEnabled ? 'ðŸ”Š AUDIO: ON' : 'ðŸ”‡ AUDIO: OFF';
  if (audioEnabled) {
    playTone(600, 0.1, 'sine', 0.05);
  }
});

// Prevent context menu and handle clicks
document.addEventListener('contextmenu', e => e.preventDefault());
document.addEventListener('click', () => {
  if (!isBooting) input.focus();
});

// Start boot sequence
window.addEventListener('load', () => {
  setTimeout(bootSequence, 1000);
});

// Focus management
window.addEventListener('focus', () => {
  if (!isBooting) input.focus();
});

// Disable text selection for authentic terminal feel
document.addEventListener('selectstart', e => {
  if (e.target !== input) {
    e.preventDefault();
  }
});

</script>
</body>
</html>
